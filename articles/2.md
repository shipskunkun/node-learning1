## 2章

### 08石头剪刀布。

node index.js rock ,




process.argv

	取到在控制台输入的参数
	
	包含命令行参数的数组。第一个元素是'node'，第二个参数是JavaScript文件的名字，第三个参数是任意的命令行参数。
	
	
	
### 09 模块


script

1. 脚本变多时，需要手动管理加载顺序。
2. 不同脚本之间逻辑调用，需要通过全局变量的方式。
3. 没有 html 怎么办？


export

默认是导出对象

```js
//lib.js
console.log('lala')

var lib = reqiure('/lib.js')   // {}


```

使用 exports


```
//lib.js
console.log('lala');

export.hello = 'world';
export.add = function() {
}

var lib = reqiure('/lib.js')   // 是一个对象

// {hello:   ,add: , }


```

//外面可以修改 export 导出的对象

```js
//lib.js
console.log('lala');

export.hello = 'world';
export.add = function() {
}

var lib = reqiure('/lib.js')   // 是一个对象
setTimeout(function(){
	console.log(exports)

}, 2000)


var lib = reqiure('/lib.js')   // 是一个对象
lib.plus = function() {}


```




也可以直接指向方法、或者变量

```js
// 指向方法
export.hello = 'world';
module.exports = function () {
    console.log('hello geekbang');
}

var lib = require('./lib');
console.log(lib);  //function , 没有hello属性

```

如何理解，有了module.exports ， 文件导出就不是 export 指向的对象？但是 打印出 export 还是有值的


	node为每一个模块提供了一个exports变量(可以说是一个对象)，指向 module.exports。
	这相当于每个模块中都有一句这样的命令 var exports = module.exports; 
	exports只是module.exports的快捷方式

	
	这样，在对外输出时，可以在这个变量上添加方法。例如  exports.add = function (r){return Math.PI * r *r};注意：不能把exports直接指向一个值，这样就相当于切断了 exports 和module.exports 的关系。例如 exports=function(x){console.log(x)};
	
	一个模块的对外接口，就是一个单一的值，不能使用exports输出，必须使用 module.exports输出。module.exports=function(x){console.log(x);}; 
	
	用阮老师的话来说，这两个不好区分，那就放弃 exports，只用 module.exports 就好（手动机智）


### 10 游戏改造

亮点：
	
	封装之前的电脑出招 + 判断输赢函数，module.exports ，导出为函数
	
	
	输入不用 process.argv
	使用 
	process.stdin.on('data', (buffer) => {})
	